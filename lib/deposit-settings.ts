import { create } from 'zustand';
import { persist, createJSONStorage } from 'zustand/middleware';
import { createClient, type SupabaseClient } from '@supabase/supabase-js';

// Crypto wallet configuration
export interface CryptoWallet {
  id: string;
  symbol: string;
  name: string;
  network: string;
  address: string;
  qrCode?: string; // Base64 or URL
  enabled: boolean;
  minDeposit: number;
  confirmations: number;
  icon: string;
}

// Bank account configuration
export interface BankAccount {
  id: string;
  bankName: string;
  accountName: string;
  accountNumber: string;
  routingNumber?: string;
  swiftCode?: string;
  iban?: string;
  country: string;
  currency: string;
  enabled: boolean;
  minDeposit: number;
  instructions?: string;
}

// Mobile money / Payment processor
export interface PaymentProcessor {
  id: string;
  name: string;
  type: 'mobile_money' | 'card' | 'ewallet' | 'other';
  accountId: string; // Phone number, email, etc.
  accountName: string;
  country?: string;
  enabled: boolean;
  minDeposit: number;
  fee: string;
  instructions?: string;
  icon: string;
}

// Pending deposit from user
export interface PendingDeposit {
  id: string;

  // Human-friendly reference generated by the platform (NOT the blockchain hash)
  orderId: string;

  amount: number;
  method: 'crypto' | 'bank' | 'processor';

  methodId: string; // Which crypto/bank/processor was used
  methodName: string;

  transactionRef?: string; // User provided reference / tx hash
  proofImage?: string; // URL (or Base64 before upload)

  userId: string;
  userEmail: string;

  status: 'pending' | 'confirmed' | 'rejected';

  // Persist-friendly timestamps
  createdAt: string; // ISO string
  processedAt?: string; // ISO string
  processedBy?: string;
  note?: string;
}

// Input type for user submissions (UI should NOT supply system/admin fields)
export type SubmitDepositInput = Omit<
  PendingDeposit,
  | 'id'
  | 'orderId'
  | 'status'
  | 'createdAt'
  | 'processedAt'
  | 'processedBy'
  | 'note'
>;

// Platform settings
export interface DepositSettings {
  // Crypto wallets (admin controlled)
  cryptoWallets: CryptoWallet[];
  // Bank accounts (admin controlled)
  bankAccounts: BankAccount[];
  // Payment processors (mobile money, etc.)
  paymentProcessors: PaymentProcessor[];
  // Pending deposits awaiting admin confirmation
  pendingDeposits: PendingDeposit[];
  // Processed deposits history (confirmed + rejected)
  confirmedDeposits: PendingDeposit[];

  // Global settings
  globalMinDeposit: number;
  depositInstructions: string;
  supportEmail: string;
  supportWhatsApp?: string;
  requireProof: boolean;
  autoApproveThreshold: number; // 0 = manual approval for all
}

interface DepositSettingsStore extends DepositSettings {
  // Crypto wallet management
  addCryptoWallet: (wallet: Omit<CryptoWallet, 'id'>) => void;
  updateCryptoWallet: (id: string, updates: Partial<CryptoWallet>) => void;
  removeCryptoWallet: (id: string) => void;
  toggleCryptoWallet: (id: string) => void;

  // Bank account management
  addBankAccount: (account: Omit<BankAccount, 'id'>) => void;
  updateBankAccount: (id: string, updates: Partial<BankAccount>) => void;
  removeBankAccount: (id: string) => void;
  toggleBankAccount: (id: string) => void;

  // Payment processor management
  addPaymentProcessor: (processor: Omit<PaymentProcessor, 'id'>) => void;
  updatePaymentProcessor: (id: string, updates: Partial<PaymentProcessor>) => void;
  removePaymentProcessor: (id: string) => void;
  togglePaymentProcessor: (id: string) => void;

  // Deposit management
  submitDeposit: (deposit: SubmitDepositInput) => Promise<string>;
  confirmDeposit: (depositId: string, adminId: string, note?: string) => PendingDeposit | null;
  rejectDeposit: (depositId: string, adminId: string, note?: string) => PendingDeposit | null;

  // Settings
  updateGlobalSettings: (
    settings: Partial<
      Pick<
        DepositSettings,
        | 'globalMinDeposit'
        | 'depositInstructions'
        | 'supportEmail'
        | 'supportWhatsApp'
        | 'requireProof'
        | 'autoApproveThreshold'
      >
    >
  ) => void;

  // Getters
  getEnabledCryptoWallets: () => CryptoWallet[];
  getEnabledBankAccounts: () => BankAccount[];
  getEnabledPaymentProcessors: () => PaymentProcessor[];
  getPendingDeposits: () => PendingDeposit[];
  getUserDeposits: (userId: string) => PendingDeposit[];
}

// -------------------- Defaults --------------------

// Default crypto wallets (admin should update these)
const defaultCryptoWallets: CryptoWallet[] = [
  {
    id: 'btc-1',
    symbol: 'BTC',
    name: 'Bitcoin',
    network: 'Bitcoin',
    address: 'bc1qxy2kgdygjrsqtzq2n0yrf2493p83kkfjhx0wlh',
    enabled: true,
    minDeposit: 50,
    confirmations: 3,
    icon: 'â‚¿'
  },
  {
    id: 'eth-1',
    symbol: 'ETH',
    name: 'Ethereum',
    network: 'ERC-20',
    address: '0x742d35Cc6634C0532925a3b844Bc454e4438f44E',
    enabled: true,
    minDeposit: 50,
    confirmations: 12,
    icon: 'Îž'
  },
  {
    id: 'usdt-trc20',
    symbol: 'USDT',
    name: 'Tether',
    network: 'TRC-20',
    address: 'TN3W4H6rK2ce4vX9YnFQHwKENnHjoxb3m9',
    enabled: true,
    minDeposit: 20,
    confirmations: 20,
    icon: 'â‚®'
  },
  {
    id: 'usdt-erc20',
    symbol: 'USDT',
    name: 'Tether',
    network: 'ERC-20',
    address: '0x742d35Cc6634C0532925a3b844Bc454e4438f44E',
    enabled: true,
    minDeposit: 50,
    confirmations: 12,
    icon: 'â‚®'
  },
  {
    id: 'sol-1',
    symbol: 'SOL',
    name: 'Solana',
    network: 'Solana',
    address: '5eykt4UsFv8P8NJdTREpY1vzqKqZKvdpKuc147dw2N9d',
    enabled: false,
    minDeposit: 25,
    confirmations: 32,
    icon: 'â—Ž'
  }
];

// Default bank accounts (admin should update these)
const defaultBankAccounts: BankAccount[] = [
  {
    id: 'bank-1',
    bankName: 'First National Bank',
    accountName: 'Nova Trade Ltd',
    accountNumber: '1234567890',
    routingNumber: '021000021',
    country: 'United States',
    currency: 'USD',
    enabled: false,
    minDeposit: 100,
    instructions: 'Please use your account email as the payment reference.'
  }
];

// Default payment processors
const defaultPaymentProcessors: PaymentProcessor[] = [
  {
    id: 'paypal-1',
    name: 'PayPal',
    type: 'ewallet',
    accountId: 'payments@novatrade.com',
    accountName: 'Nova Trade Ltd',
    enabled: false,
    minDeposit: 50,
    fee: '3.5%',
    instructions: 'Send as Friends & Family to avoid fees.',
    icon: 'ðŸ’³'
  },
  {
    id: 'cashapp-1',
    name: 'Cash App',
    type: 'ewallet',
    accountId: '$NovaTradeOfficial',
    accountName: 'Nova Trade',
    country: 'United States',
    enabled: false,
    minDeposit: 25,
    fee: '0%',
    instructions: 'Include your registered email in the note.',
    icon: 'ðŸ’µ'
  }
];

// -------------------- Helpers --------------------

const generateId = () => {
  const c = (globalThis as any).crypto;
  if (c && typeof c.randomUUID === 'function') return c.randomUUID();
  return `${Date.now()}-${Math.random().toString(36).slice(2, 11)}`;
};

const generateOrderId = () => {
  const ts = Date.now().toString(36).toUpperCase();
  const rnd = Math.random().toString(36).slice(2, 7).toUpperCase();
  return `DEP-${ts}-${rnd}`;
};

let _supabase: SupabaseClient | null = null;
function getSupabase(): SupabaseClient {
  if (_supabase) return _supabase;

  const url = process.env.NEXT_PUBLIC_SUPABASE_URL;
  const anon = process.env.NEXT_PUBLIC_SUPABASE_ANON_KEY;
  if (!url || !anon) {
    throw new Error('Missing NEXT_PUBLIC_SUPABASE_URL or NEXT_PUBLIC_SUPABASE_ANON_KEY');
  }

  _supabase = createClient(url, anon);
  return _supabase;
}

function dataUrlToBlob(dataUrl: string): { blob: Blob; mime: string; ext: string } {
  const [meta, base64] = dataUrl.split(',');
  const mimeMatch = meta.match(/data:(.*?);base64/);
  const mime = mimeMatch?.[1] || 'image/png';
  const ext = mime.includes('jpeg') ? 'jpg' : mime.includes('png') ? 'png' : 'bin';

  const bytes = Uint8Array.from(atob(base64), (c) => c.charCodeAt(0));
  return { blob: new Blob([bytes], { type: mime }), mime, ext };
}

async function uploadDepositProof(params: {
  userId: string;
  orderId: string;
  proofImage: string; // data url
}): Promise<string> {
  const supabase = getSupabase();

  // Create this bucket in Supabase Storage (Dashboard): deposit_proofs
  const BUCKET = 'deposit_proofs';

  const { blob, mime, ext } = dataUrlToBlob(params.proofImage);
  const path = `deposits/${params.userId}/${params.orderId}.${ext}`;

  const { error: upErr } = await supabase.storage.from(BUCKET).upload(path, blob, {
    contentType: mime,
    upsert: true
  });

  if (upErr) {
    throw new Error(
      `Proof upload failed. Create a Storage bucket named "${BUCKET}" (or fix its policies). Error: ${upErr.message}`
    );
  }

  // If bucket is public, this works immediately. If not, store the path and create signed URLs in admin.
  const { data } = supabase.storage.from(BUCKET).getPublicUrl(path);
  return data.publicUrl || path;
}

// -------------------- Store --------------------

export const useDepositSettingsStore = create<DepositSettingsStore>()(
  persist(
    (set, get) => ({
      cryptoWallets: defaultCryptoWallets,
      bankAccounts: defaultBankAccounts,
      paymentProcessors: defaultPaymentProcessors,

      pendingDeposits: [],
      confirmedDeposits: [],

      globalMinDeposit: 20,
      depositInstructions:
        'After making your deposit, please submit the transaction details below. Our team will verify and credit your account within 1-24 hours.',
      supportEmail: 'support@novatrade.com',
      supportWhatsApp: '+1234567890',
      requireProof: true,
      autoApproveThreshold: 0,

      // Crypto wallet management
      addCryptoWallet: (wallet) =>
        set((state) => ({
          cryptoWallets: [...state.cryptoWallets, { ...wallet, id: generateId() }]
        })),

      updateCryptoWallet: (id, updates) =>
        set((state) => ({
          cryptoWallets: state.cryptoWallets.map((w) => (w.id === id ? { ...w, ...updates } : w))
        })),

      removeCryptoWallet: (id) =>
        set((state) => ({
          cryptoWallets: state.cryptoWallets.filter((w) => w.id !== id)
        })),

      toggleCryptoWallet: (id) =>
        set((state) => ({
          cryptoWallets: state.cryptoWallets.map((w) => (w.id === id ? { ...w, enabled: !w.enabled } : w))
        })),

      // Bank account management
      addBankAccount: (account) =>
        set((state) => ({
          bankAccounts: [...state.bankAccounts, { ...account, id: generateId() }]
        })),

      updateBankAccount: (id, updates) =>
        set((state) => ({
          bankAccounts: state.bankAccounts.map((a) => (a.id === id ? { ...a, ...updates } : a))
        })),

      removeBankAccount: (id) =>
        set((state) => ({
          bankAccounts: state.bankAccounts.filter((a) => a.id !== id)
        })),

      toggleBankAccount: (id) =>
        set((state) => ({
          bankAccounts: state.bankAccounts.map((a) => (a.id === id ? { ...a, enabled: !a.enabled } : a))
        })),

      // Payment processor management
      addPaymentProcessor: (processor) =>
        set((state) => ({
          paymentProcessors: [...state.paymentProcessors, { ...processor, id: generateId() }]
        })),

      updatePaymentProcessor: (id, updates) =>
        set((state) => ({
          paymentProcessors: state.paymentProcessors.map((p) => (p.id === id ? { ...p, ...updates } : p))
        })),

      removePaymentProcessor: (id) =>
        set((state) => ({
          paymentProcessors: state.paymentProcessors.filter((p) => p.id !== id)
        })),

      togglePaymentProcessor: (id) =>
        set((state) => ({
          paymentProcessors: state.paymentProcessors.map((p) => (p.id === id ? { ...p, enabled: !p.enabled } : p))
        })),

      // âœ… Deposit management (NOW SAVES TO SUPABASE)
      submitDeposit: async (deposit) => {
        const supabase = getSupabase();

        const orderId = generateOrderId();

        const isCrypto = deposit.method === 'crypto';

        const state = get();
        const cryptoCfg = isCrypto ? state.cryptoWallets.find((w) => w.id === deposit.methodId) : null;
        const bankCfg = deposit.method === 'bank' ? state.bankAccounts.find((b) => b.id === deposit.methodId) : null;

        const currency =
          (isCrypto ? cryptoCfg?.symbol : bankCfg?.currency) || 'USD';

        // Upload proof if provided (recommended)
        let proofUrl: string | null = null;
        if (deposit.proofImage) {
          // proofImage comes as base64 data url from UI
          proofUrl = await uploadDepositProof({
            userId: deposit.userId,
            orderId,
            proofImage: deposit.proofImage
          });
        }

        // âœ… Correct DB column names (NO network, NO tx_hash)
        const row = {
          user_id: deposit.userId,
          amount: deposit.amount,
          currency,

          method: deposit.method, // 'crypto' | 'bank' | 'processor'
          status: 'pending',

          // platform-friendly id
          payment_reference: orderId,

          // crypto-only (blockchain hash)
          transaction_hash: isCrypto ? (deposit.transactionRef || null) : null,

          // crypto-only (the deposit address user sent to)
          wallet_address: isCrypto ? (cryptoCfg?.address || null) : null,

          // proof url
          payment_proof_url: proofUrl,

          // store UI-friendly details here
          sender_info: {
            userEmail: deposit.userEmail,
            methodId: deposit.methodId,
            methodName: deposit.methodName,
            network: cryptoCfg?.network || null,
            user_reference: !isCrypto ? (deposit.transactionRef || null) : null
          }
        };

        const { data, error } = await supabase
          .from('deposits')
          .insert(row)
          .select('id, status, created_at, processed_at, processed_by, rejection_reason, notes, payment_reference')
          .single();

        if (error) {
          throw new Error(error.message);
        }

        const saved: PendingDeposit = {
          id: data.id,
          orderId: data.payment_reference || orderId,

          amount: deposit.amount,
          method: deposit.method,

          methodId: deposit.methodId,
          methodName: deposit.methodName,

          transactionRef: deposit.transactionRef,
          proofImage: proofUrl || undefined,

          userId: deposit.userId,
          userEmail: deposit.userEmail,

          status: (data.status as any) || 'pending',

          createdAt: data.created_at ? new Date(data.created_at).toISOString() : new Date().toISOString(),
          processedAt: data.processed_at ? new Date(data.processed_at).toISOString() : undefined,
          processedBy: data.processed_by || undefined,
          note: data.notes || data.rejection_reason || undefined
        };

        set((state) => ({
          pendingDeposits: saved.status === 'pending' ? [saved, ...state.pendingDeposits] : state.pendingDeposits,
          confirmedDeposits: saved.status !== 'pending' ? [saved, ...state.confirmedDeposits] : state.confirmedDeposits
        }));

        return saved.id;
      },

      // (Still local for now â€” admin confirmation should update DB server-side)
      confirmDeposit: (depositId, adminId, note) => {
        const state = get();
        const deposit = state.pendingDeposits.find((d) => d.id === depositId);
        if (!deposit) return null;

        const confirmedDeposit: PendingDeposit = {
          ...deposit,
          status: 'confirmed',
          processedAt: new Date().toISOString(),
          processedBy: adminId,
          note
        };

        set((state) => ({
          pendingDeposits: state.pendingDeposits.filter((d) => d.id !== depositId),
          confirmedDeposits: [...state.confirmedDeposits, confirmedDeposit]
        }));

        return confirmedDeposit;
      },

      rejectDeposit: (depositId, adminId, note) => {
        const state = get();
        const deposit = state.pendingDeposits.find((d) => d.id === depositId);
        if (!deposit) return null;

        const rejectedDeposit: PendingDeposit = {
          ...deposit,
          status: 'rejected',
          processedAt: new Date().toISOString(),
          processedBy: adminId,
          note
        };

        set((state) => ({
          pendingDeposits: state.pendingDeposits.filter((d) => d.id !== depositId),
          confirmedDeposits: [...state.confirmedDeposits, rejectedDeposit]
        }));

        return rejectedDeposit;
      },

      // Settings
      updateGlobalSettings: (settings) =>
        set((state) => ({
          ...state,
          ...settings
        })),

      // Getters
      getEnabledCryptoWallets: () => get().cryptoWallets.filter((w) => w.enabled),
      getEnabledBankAccounts: () => get().bankAccounts.filter((a) => a.enabled),
      getEnabledPaymentProcessors: () => get().paymentProcessors.filter((p) => p.enabled),

      getPendingDeposits: () => get().pendingDeposits,

      getUserDeposits: (userId) =>
        [
          ...get().pendingDeposits.filter((d) => d.userId === userId),
          ...get().confirmedDeposits.filter((d) => d.userId === userId)
        ].sort((a, b) => new Date(b.createdAt).getTime() - new Date(a.createdAt).getTime())
    }),
    {
      name: 'deposit-settings-storage',
      storage: createJSONStorage(() => localStorage)
    }
  )
);
